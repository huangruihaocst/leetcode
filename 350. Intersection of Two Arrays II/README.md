# 350. Intersection of Two Arrays II

## Solution

### 方法一

对于`nums1`中的元素，如果`nums2`中有就加入结果列表，并从`nums2`中删除。
复杂度为`O(mn)`，`m`和`n`分别是`nums1`和`nums2`的长度。

一开始忘记删除，差太远了。

### 方法二

首先记录`nums1`中的各元素出现的次数，用字典保存。然后遍历`nums2`的时候如果字典中相同元素个数大于`0`，
则加入结果列表，并在上述字典中该元素剩余个数减一。复杂度为`O(m + n)`。

此外，`collections.Counter`对象可以用方括号访问，也能修改，比如
```Python
li = [1, 2, 3, 1]
counter = Counter(li)
counter[3] += 1
```

### 方法三

先对两个列表分别排序，然后设置两个指针`i`和`j`分别指向`nums1`和`nums2`的头。
逐渐移动两个指针，如果指针指的值相等则加入结果列表，都向后移；如果一个大一个小，则小的向后移。
复杂度为`O(mlogm + nlogn + m + n)`。

## Follow Up

1. 方法三。

2. 为了节省空间，可以对较小的数组进行建立字典，使用方法二。

3. 如果只有`nums2`太大放不进内存，用方法二，把`nums1`变成字典放进内存，
然后每次读`nums2`的一部分进行计算。

    如果`nums1`也放不进内存，则把二者进行排序（外存排序），内存中用两个指针指向两个数组的下标，
    进行移动。