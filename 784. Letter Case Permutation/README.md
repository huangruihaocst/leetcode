# 784. Letter Case Permutation

## Solution

我的方法太慢了，复杂度为`O(len(S) * 2 ^ len(S))`。不过得知了`itertools`中的`repeat`方法可以获得所有排序。

答案中的方法比较巧妙，实际是一种DFS算法。一开始结果列表`res`中只有一个空字符串，然后遍历整个`S`。使用`isaplha`方法判断新字符`c`是字母还是数字。如果是字母，则对`res`中的每一个半成的结果，后面追加一个`c.lower()`或者追加一个`c.upper()`，这两个都要追加，并把两个新的结果放回`res`。如果`res`当前有`2 ^ k`个长度为`l`的半成品结果，则如果`c`是字母，经过这次操作，`res`中含有`2 ^ (k + 1)`个长度为`l + 1`的半成品结果。如果`c`是数字，直接追加这个数字即可。同样地，如果`res`当前有`2 ^ k`个长度为`l`的半成品结果，经过这次操作`res`中将有`2 ^ k`个长度为`l + 1`的半成品结果。复杂度最高也为`O(len(S) * 2 ^ len(S))`。
