# 53. Maximum Subarray

## Solution

### 方法一

设目标数列为${a_n}$，设${S_n}$表示前$n$项和，那么，
只需要找到$i<j$且$S_j-S_i$最大即可。那么，遍历${S_n}$，
记录当前最小值，并计算当前遍历到的数和最小值的差，
并更新最小值即可。

### 方法二

动态规划。

设`dp[i]`表示`A[i]`一定是子数组的最后一个元素时，最大的子数组和。
那么，最终的结果就是`max(dp[0], dp[1], ..., dp[len(A) - 1])`。

状态转移方程：

考虑`dp[i]`和`dp[i - 1]`的关系，只有可能是`A[i]`或者`dp[i - 1] + A[i]`。
因为，假设之前`dp[i - 1]`是`A[k], A[k + 1], ..., A[i - 1]`的子数组和最大，
而当考虑到`dp[i]`时，如果不是也从`A[k]`开始算而导致和更大，
比如`A[j], A[j + 1], ..., A[i - 1], A[i]`，这个和比
`A[k], A[k + 1], ..., A[i - 1], A[i]`的和大，那么去掉`A[i]`，
`A[j], A[j + 1], ..., A[i - 1]`也会比`A[k]`开始的大，从而与`dp[i - 1]`
的假设矛盾。因此，只有可能是`A[i]`自己更大，或者`dp[i - 1] + A[i]`更大。
于是，状态转移方程为`dp[i] = max(dp[i - 1] + A[i], A[i])`。

之后再求出`max(dp[0], dp[1], ..., dp[len(A) - 1])`即可（可以通过循环时更新节省空间）。